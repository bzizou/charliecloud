#!/usr/bin/env python3

import argparse
import inspect
import json
import os
import pathlib
import stat
import subprocess
import sys

import lark


## Constants ##

CH_BIN = os.path.dirname(os.path.abspath(
           inspect.getframeinfo(inspect.currentframe()).filename))

GRAMMAR = r"""
?start: ( instruction | _COMMENT )+

?instruction: ( cmd | env | from_ | run )

cmd: "CMD"i LINE_GREEDY _NEWLINES

env: "ENV"i ( env_space | env_equals ) _NEWLINES
env_space: WORD WORD_SEP LINE_GREEDY
env_equals: WORD "=" ( WORD | STRING_QUOTED )

from_: "FROM"i ID [ from_tag | from_digest ] [ from_alias ] _NEWLINES
from_tag: ":" ID
from_digest: "@" HEXID
from_alias: "AS"i ID

run: "RUN"i ( run_exec | run_shell ) _NEWLINES
run_exec: _string_list
run_shell: LINE

ID: /[A-Za-z0-9_.-]+/
HEXID: /[a-fA-F0-9]+/
LINE:        /[^[ \t\n]/ ( LINE_CONTINUE | /[^\n]/ )+  // doesn't eat lists
LINE_GREEDY: /[^ \t\n]/ ( LINE_CONTINUE | /[^\n]/ )+  // eats lists
//WORD: /[^ \t\n=]/+
WORD: /[a-z0-9_]/+
WORD_SEP: /[ \t]/+

_string_list: "[" STRING_QUOTED ( "," STRING_QUOTED )* "]"

LINE_CONTINUE: "\\\n"
%ignore LINE_CONTINUE

_COMMENT: /#[^\n]*/ _NEWLINES
_NEWLINES: "\n"+

%import common.ESCAPED_STRING -> STRING_QUOTED
%import common.WS_INLINE
%ignore WS_INLINE
"""


## Globals ##

# Command line arguments.
cli = None


## Main ##

def main():

   global cli
   ap = argparse.ArgumentParser()
   ap.add_argument("-n", "--dry-run", action="store_true")
   ap.add_argument("--stop-after-parse", action="store_true")
   ap.add_argument("-s", "--storage", metavar="DIR", default="/var/tmp/ch-grow")
   ap.add_argument("--verbose", action="store_true")
   ap.add_argument("dockerfile", metavar="DOCKERFILE")
   cli = ap.parse_args()
   DEBUG(cli)

   # Use LALR(1) parser because Earley has some non-deterministic behavior
   # (comments sometimes in tree, sometimes not).
   parser = lark.Lark(GRAMMAR, parser="lalr", propagate_positions=True)
   text = open(cli.dockerfile, "rt").read()
   tree = parser.parse(text)

   DEBUG(tree.pretty())
   if (cli.stop_after_parse):
      sys.exit(0)

   mkdir(cli.storage)
   Main_Loop().visit(tree)


class Main_Loop(lark.Visitor):

   def __default__(self, tree):
      class_ = "I_" + tree.data
      if (class_ in globals()):
         inst = globals()[class_](tree)
         INFO(inst)
         inst.execute()


## Instruction classes ##

class Instruction(object):

   def __init__(self, tree):
      self.lineno = tree.meta.line
      self.tree = tree

   def __str__(self):
      return ("%3s %s %s"
              % (self.lineno, self.__class__.__name__.split("_")[1].upper(),
                 self.str_()))

   # Return the value of first immediate subtree childname's first immediate
   # child terminal of type type_, or None if either the child or terminal
   # does not exist.
   def child(self, childname, type_):
      children = self.tree.find_data(childname)
      try:
         child = next(children)
      except StopIteration:
         return None  # no child subtree named childname
      return terminal(child, type_)

   def execute(self):
      if (not cli.dry_run):
         self.execute_()

   def execute_(self):
      pass

   def str_(self):
      return "(unimplemented)"

   # Return value of first immediate child terminal of type type_, or None if
   # not found.
   def terminal(self, type_):
      return terminal(self.tree, type_)

   # Yield values of all immediate child terminals of type type_, or empty
   # list if none found.
   def terminals(self, type_):
      return terminals(self.tree, type_)


class I_cmd(Instruction):
   pass


class I_env_space(Instruction):

   def __init__(self, *args):
      super().__init__(*args)
      self.key = self.terminal("WORD")
      value = self.terminal("LINE")
      if (not value.startswith('"')):
         value = '"' + value + '"'
      self.value = unescape(value)

   def str_(self):
      return "%s=%s" % (self.key, self.value)

class I_from_(Instruction):

   def __init__(self, *args):
      super().__init__(*args)
      self.name = self.terminal("ID")
      self.alias = self.child("from_alias", "ID")
      self.tag = self.child("from_tag", "ID")
      self.digest = self.child("from_digest", "HEXID")
      if (self.tag is None and self.digest is None):
         self.tag = "latest"

   @property
   def fullname(self):
      if (self.tag is not None):
         return "%s:%s" % (self.name, self.tag)
      elif (self.digest is not None):
         return "%s@%s" % (self.name, self.digest)
      else:
         return self.name

   def execute_(self):
      # This works with newuidmap and newgidmap not installed.
      cmd(["skopeo", "copy", "docker://" + self.fullname,
           "oci:%s/oci_%s" % (cli.storage, self.fullname)])
      cmd(["umoci", "unpack", "--rootless",
           "--image", "%s/oci_%s" % (cli.storage, self.fullname),
           cli.storage + "/img"])
      # CentOS likes to leave unwriteable directories, so fix that.
      def reraise(x):
         raise
      for (root, dirs, files) in \
          os.walk(cli.storage + "/img", topdown=True, onerror=reraise):
         st = os.stat(root, follow_symlinks=False)
         if (not st.st_mode & 0o200):
            DEBUG("fixing bad permissions: %s %s"
                  % (stat.filemode(st.st_mode), root))
            os.chmod(root, st.st_mode | 0o200)

   def str_(self):
      alias = "AS %s" % self.alias if self.alias else ""
      return "%s %s" % (self.fullname, alias)


class Run(Instruction):

   def execute_(self):
      rootfs = cli.storage + "/img/rootfs"
      pathlib.Path(rootfs + "/etc/resolv.conf").touch(exist_ok=True)
      pathlib.Path(rootfs + "/etc/hosts").touch(exist_ok=True)
      args = [CH_BIN + "/ch-run", "-w", "--uid=0", "--gid=0",
              rootfs, "--"] + self.cmd
      cmd(args)

   def str_(self):
      return str(self.cmd)


class I_run_exec(Run):

   def __init__(self, *args):
      super().__init__(*args)
      self.cmd = [unescape(i) for i in self.terminals("STRING_QUOTED")]


class I_run_shell(Run):

   def __init__(self, *args):
      super().__init__(*args)
      self.cmd = ["/bin/sh", "-c", self.terminal("LINE")]


## Supporting functions ###

def DEBUG(*args, **kwargs):
   if (cli.verbose):
      print("\033[36m", file=sys.stderr, flush=True, end="")
      print(flush=True, file=sys.stderr, *args, **kwargs)
      print("\033[0m", file=sys.stderr, flush=True, end="")

def INFO(*args, **kwargs):
   print(flush=True, *args, **kwargs)

def cmd(args, env=None):
   DEBUG("executing: " + str(args))
   INFO("\033[33m", end="")
   subprocess.run(args, env=env, stdin=subprocess.DEVNULL)
   INFO("\033[0m", end="")

def mkdir(path):
   try:
      os.mkdir(path)
      DEBUG("created directory: " + path)
   except FileExistsError:
      DEBUG("using existing directory: " + path)

def terminal(tree, type_):
   for i in tree.children:
      if (isinstance(i, lark.lexer.Token) and i.type == type_):
         return i.value
   return None

def terminals(tree, type_):
   for i in tree.children:
      if (isinstance(i, lark.lexer.Token) and i.type == type_):
         yield i.value

def unescape(string_literal):
   # Dockerfile spec does not say how to unescape strings, so let's JSON it.
   return json.loads(string_literal)


## Bootstrap ##

if (__name__ == "__main__"):
   main()



