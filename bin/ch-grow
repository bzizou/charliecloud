#!/usr/bin/env python3

import argparse
import inspect
import json
import os
import pathlib
import re
import shutil
import stat
import subprocess
import sys

import lark


## Constants ##

CH_BIN = os.path.dirname(os.path.abspath(
           inspect.getframeinfo(inspect.currentframe()).filename))

GRAMMAR = r"""
?start: ( instruction | _COMMENT )+

?instruction: _WS? ( cmd | env | from_ | run )

cmd: "CMD"i LINE _NEWLINES

env: "ENV"i _WS ( env_space | env_equalses ) _NEWLINES
env_space: WORD _WS LINE
env_equalses: env_equals ( _WS env_equals )*
env_equals: WORD "=" ( WORD | STRING_QUOTED )

from_: "FROM"i _WS ID [ from_tag | from_digest ] [ from_alias ] _NEWLINES
from_tag: ":" ID
from_digest: "@" HEXID
from_alias: "AS"i ID

run: "RUN"i _WS ( run_exec | run_shell ) _NEWLINES
run_exec: _string_list
run_shell: LINE_NOLIST

ID: /[A-Za-z0-9_.-]+/
HEXID: /[a-fA-F0-9]+/
LINE: ( LINE_CONTINUE | /[^\n]/ )+
LINE_NOLIST: /[^[]/ ( LINE_CONTINUE | /[^\n]/ )+
WORD: /[^ \t\n=]/+

_string_list: "[" _WS? STRING_QUOTED ( "," _WS? STRING_QUOTED )* _WS? "]"

LINE_CONTINUE: "\\\n"
%ignore LINE_CONTINUE

_COMMENT: _WS? /#[^\n]*/ _NEWLINES
_NEWLINES: _WS? "\n"+
_WS: /[ \t]/+

%import common.ESCAPED_STRING -> STRING_QUOTED
"""


## Globals ##

# Command line arguments.
cli = None

# Image state object.
state = None


## Main ##

def main():

   global cli
   ap = argparse.ArgumentParser()
   ap.add_argument("-n", "--dry-run", action="store_true")
   ap.add_argument("--parse-only", action="store_true")
   ap.add_argument("-s", "--storage", metavar="DIR", default="/var/tmp/ch-grow")
   ap.add_argument("--verbose", action="store_true")
   ap.add_argument("-t", "--tag", metavar="NAME")
   ap.add_argument("dockerfile", metavar="DOCKERFILE")
   cli = ap.parse_args()
   if (cli.tag is None):
      m = re.search(r"(([^/]+)/)?Dockerfile(\.(.+))?$",
                    os.path.abspath(cli.dockerfile))
      if (m is not None):
         if m.group(4):    # extension
            cli.tag = m.group(4)
         elif m.group(2):  # containing directory
            cli.tag = m.group(2)
   if (":" not in cli.tag):
      cli.tag += ":latest"
   INFO("growing: %s" % dir_image(cli.tag))
   DEBUG(cli)

   global state
   state = State()

   # Use LALR(1) parser because Earley has some non-deterministic behavior
   # (comments sometimes in tree, sometimes not).
   parser = lark.Lark(GRAMMAR, parser="lalr", propagate_positions=True)
   text = open(cli.dockerfile, "rt").read()
   tree = parser.parse(text)

   DEBUG(tree.pretty())
   if (cli.parse_only):
      sys.exit(0)

   Main_Loop().visit(tree)


class Main_Loop(lark.Visitor):

   def __default__(self, tree):
      class_ = "I_" + tree.data
      if (class_ in globals()):
         inst = globals()[class_](tree)
         INFO(inst)
         inst.execute()


## Instruction classes ##

class Instruction(object):

   def __init__(self, tree):
      self.lineno = tree.meta.line
      self.tree = tree

   def __str__(self):
      return ("%3s %s %s"
              % (self.lineno, self.__class__.__name__.split("_")[1].upper(),
                 self.str_()))

   # Return the value of first immediate subtree childname's first immediate
   # child terminal of type type_, or None if either the child or terminal
   # does not exist.
   def child(self, childname, type_):
      children = self.tree.find_data(childname)
      try:
         child = next(children)
      except StopIteration:
         return None  # no child subtree named childname
      return terminal(child, type_)

   def execute(self):
      if (not cli.dry_run):
         self.execute_()

   def execute_(self):
      pass

   def str_(self):
      return "(unimplemented)"

   # Return value of first immediate child terminal of type type_, or None if
   # not found.
   def terminal(self, type_, index=0):
      return terminal(self.tree, type_, index)

   # Yield values of all immediate child terminals of type type_, or empty
   # list if none found.
   def terminals(self, type_):
      return terminals(self.tree, type_)


class I_cmd(Instruction):
   pass


class Env(Instruction):

   def str_(self):
      return "%s='%s'" % (self.key, self.value)

   def execute_(self):
      state.env[self.key] = self.value


class I_env_equals(Env):

   def __init__(self, *args):
      super().__init__(*args)
      self.key = self.terminal("WORD", 0)
      self.value = self.terminal("WORD", 1)
      if (self.value is None):
         self.value = self.terminal("STRING_QUOTED")


class I_env_space(Env):

   def __init__(self, *args):
      super().__init__(*args)
      self.key = self.terminal("WORD")
      value = self.terminal("LINE")
      if (not value.startswith('"')):
         value = '"' + value + '"'
      self.value = unescape(value)


class I_from_(Instruction):

   def __init__(self, *args):
      super().__init__(*args)
      self.name = self.terminal("ID")
      self.alias = self.child("from_alias", "ID")
      self.tag = self.child("from_tag", "ID")
      self.digest = self.child("from_digest", "HEXID")
      if (self.tag is None and self.digest is None):
         self.tag = "latest"

   @property
   def fullname(self):
      if (self.tag is not None):
         return "%s:%s" % (self.name, self.tag)
      elif (self.digest is not None):
         return "%s@%s" % (self.name, self.digest)
      else:
         return self.name

   def base_copy(self):
      DEBUG("copying: %s -> %s" % (self.fullname, cli.tag))
      rmtree(dir_image(cli.tag))
      shutil.copytree(dir_image(self.fullname), dir_image(cli.tag),
                      symlinks=True)

   def base_pull(self):
      mkdirs(dir_ocis())
      rmtree(dir_image_tmp())
      # This works with newuidmap and newgidmap not installed.
      cmd(["skopeo", "copy", "docker://" + self.fullname,
           "oci:%s/%s" % (dir_ocis(), self.fullname)])
      cmd(["umoci", "unpack", "--rootless",
           "--image", "%s/%s" % (dir_ocis(), self.fullname), dir_image_tmp()])
      rmtree(dir_image(self.fullname))
      os.rename("%s/rootfs" % dir_image_tmp(), dir_image(self.fullname))
      rmtree(dir_image_tmp())
      # CentOS likes to leave directories unwriteable by anyone, and files
      # unreadable by anyone, so fix that.
      def reraise(x):
         raise
      def fix(path, mode):
         st = os.stat(path, follow_symlinks=False)
         if (not st.st_mode & mode):
            DEBUG("fixing bad permissions: %s %s"
                  % (stat.filemode(st.st_mode), path))
            os.chmod(path, st.st_mode | mode)
      for (root, dirs, files) in \
          os.walk(dir_image(self.fullname), topdown=True, onerror=reraise):
         fix(root, 0o200)
         for path in files:
            fix("%s/%s" % (root, path), 0o400)

   def execute_(self):
      mkdirs(dir_images())
      if (not os.path.isdir(dir_image(self.fullname))):
         DEBUG("image not found, pulling: %s" % self.fullname)
         self.base_pull()
      self.base_copy()
      state.env_reset()

   def str_(self):
      alias = "AS %s" % self.alias if self.alias else ""
      return "%s %s" % (self.fullname, alias)


class Run(Instruction):

   def execute_(self):
      rootfs = dir_image(cli.tag)
      pathlib.Path(rootfs + "/etc/resolv.conf").touch(exist_ok=True)
      pathlib.Path(rootfs + "/etc/hosts").touch(exist_ok=True)
      args = [CH_BIN + "/ch-run", "-w", "--no-home", "--uid=0", "--gid=0",
              rootfs, "--"] + self.cmd
      cmd(args, env=state.env_build)

   def str_(self):
      return str(self.cmd)


class I_run_exec(Run):

   def __init__(self, *args):
      super().__init__(*args)
      self.cmd = [unescape(i) for i in self.terminals("STRING_QUOTED")]


class I_run_shell(Run):

   def __init__(self, *args):
      super().__init__(*args)
      # FIXME: Can't figure out how to remove continuations at parse time.
      cmd = self.terminal("LINE_NOLIST").replace("\\\n", "")
      self.cmd = ["/bin/sh", "-c", cmd]


## Supporting classes ##

class State(object):

   def __init__(self):
      self.env_reset()

   @property
   def env_build(self):
      return { **self.arg, **self.env }

   def env_reset(self):
      self.arg = {}
      for i in ( "http_proxy", "https_proxy", "ftp_proxy", "no_proxy" ):
         for j in (i, i.upper()):
            try:
               self.arg[j] = os.environ[j]
            except KeyError:
               pass
      self.env = { "PATH": "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin" }


## Supporting functions ###

def DEBUG(*args, **kwargs):
   if (cli.verbose):
      print("\033[36m", file=sys.stderr, flush=True, end="")
      print(flush=True, file=sys.stderr, *args, **kwargs)
      print("\033[0m", file=sys.stderr, flush=True, end="")

def FATAL(*args, **kwargs):
   print("\033[31m", file=sys.stderr, flush=True, end="")
   print(flush=True, file=sys.stderr, *args, **kwargs)
   print("\033[0m", file=sys.stderr, flush=True, end="")
   sys.exit(1)

def INFO(*args, **kwargs):
   print(flush=True, *args, **kwargs)

def cmd(args, env=None):
   DEBUG("environment: %s" % env)
   DEBUG("executing: %s" % args)
   INFO("\033[33m", end="")
   cp = subprocess.run(args, env=env, stdin=subprocess.DEVNULL)
   INFO("\033[0m", end="")
   if (cp.returncode):
      FATAL("%s failed with return code %d" % (args[0], cp.returncode))

def dir_image_tmp():
   return "%s/img/tmp" % cli.storage

def dir_images():
   return "%s/img" % cli.storage

def dir_image(image):
   return "%s/%s" % (dir_images(), image)

def dir_ocis():
   return "%s/oci" % cli.storage

def mkdirs(path):
   DEBUG("ensuring directory: " + path)
   os.makedirs(path, exist_ok=True)

def rmtree(path):
   if (os.path.isdir(path)):
      DEBUG("deleting directory: " + path)
      shutil.rmtree(path)

def terminal(tree, type_, index=0):
   for (i, t) in enumerate(terminals(tree, type_)):
      if (i == index):
         return t
   return None

def terminals(tree, type_):
   for i in tree.children:
      if (isinstance(i, lark.lexer.Token) and i.type == type_):
         yield i.value

def unescape(string_literal):
   # Dockerfile spec does not say how to unescape strings, so let's JSON it.
   return json.loads(string_literal)


## Bootstrap ##

if (__name__ == "__main__"):
   main()



